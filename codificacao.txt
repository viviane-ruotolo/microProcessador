Flags: carry, overflow, zero, negative

//Opcode 15 - 12
//Só mudou o tamanho do opcode (3 downto 0)

  MSB b19                 b0 LSB
      |            fff |
B:    0001 eeeeeee xxx 000 xxx // endereço de 7 bits
BEQ:  0001 ttttttt xxx 001 xxx //Igual 
BGE:  0001 ttttttt xxx 010 xxx //Maior ou igual
BGT:  0001 ttttttt xxx 011 xxx //Maior que 
BLT:  0001 ttttttt xxx 100 xxx //Menor que 
BNE:  0001 ttttttt xxx 101 xxx //Não é igual
CMP:  0111 aaaa rrrr xxxxxxxx //x de 8 bits 
ADD:  0010 aaaa ssss xxxxxxxx 
SUB:  0100 aaaa ssss xxxxxxxx
MOV:  0110 dddd ssss xxxxxxxx
SUBI: 0011 ssss cccccccccccc //Constante de 12 bits
LD:   0101 ssss cccccccccccc //Constante de 12 bits 
NOP:  0000 xxxxxxxxxxxxxxxx // x de 16 bits
SW:   1000 ssss pppp xxxxxxxx // x de 8 bits
LW:   1001 dddd pppp xxxxxxxx 
AND:  1010 aaaa ssss xxxxxxxx 
NOT:  1011 aaaa xxxxxxxxxxxx 
END:  1111 xxxxxxxxxxxxxxxx
...
onde
dddd  identifica o registrador destino
ssss  identifica o registrador fonte
pppp  identifica o ponteiro para o endereço guardado nesse registrador
cccccccc identifica a constante de 8 bits em complemento de 2
eeeeeee identifica o endereço absoluto do salto incondicional
ttttttt identifica o delta (theta) do endereço relativo para o salto condicional
xxxx é irrelevante
fff identifica a condicional do salto(function)
aaaa representa que só pode ser o acumulador
... 
Quando dddd, pppp ou ssss = "0000": representa o R0
Quando dddd, pppp ou ssss = "0001": representa o R1
Quando dddd, pppp ou ssss = "0010": representa o R2
Quando dddd, pppp ou ssss = "0011": representa o R3 
Quando dddd, pppp ou ssss = "0100": representa o R4 
Quando dddd, pppp ou ssss = "0101": representa o R5
Quando dddd, pppp ou ssss = "0110": representa o R6 
Quando dddd, pppp ou ssss = "0111": representa o R7 
Quando dddd, pppp ou ssss = "1111": representa o RF 
Quando dddd, pppp, aaaa ou ssss = "1000": representa o acumulador (A)

...

CMP é sempre entrada1 - entrada0, ou seja, acumulador - registrador na ULA:
CMP A, R --> A - R
aaaa = acumulador 
rrrr = registrador


sw   s3,(t1)      #Escreve no endereço (7 bits) da ram guardado em t1, o dado (16 bits) em s3
lw   t2,(t1)      #Guarda no registrador t2, o dado (16 bits) lido no endereço (7 bits) guardado em t1  

sw: Salva o dado s3 no endereço apontado por t1
      - ler o reg t1 e salva no reg de end da ram 
      - ler s3 (dado_in) e escreve na ram

lw: Lê o dado gravado na ram no endereço guardado em t1 e guarda no registrador t2
      - ler o reg t1 (endereço) e salva no reg de end da ram
      - Lê ram e Salva dado_out da ram em t2 

* Fazer programa na rom para teste
* Implementar instruction register e quebrar a instrução ali dentro 

ram:
- dado in: vem do reg
- endereço: vem do reg de eendereço da ram ou banco reg
- dado lido: vai para o mux do banco regs
