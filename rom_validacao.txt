    type mem is array (0 to 127) of unsigned(19 downto 0);
    constant conteudo_rom : mem := (
        -- caso endereco => conteudo
        0  => B"0101_0001_000000000001", -- LD R1, 1
        1  => B"0101_0010_000000100000", -- LD R2, 32
        2  => B"0101_0011_000000000001", -- LD R3, 1
        
        -- ESCREVE_RAM
        3  => B"0110_1000_0011_00000000",  -- MOV A, R3
        4  => B"1000_0011_0011_00000000",  -- SW R3, (R3)
        5  => B"0010_1000_0001_00000000",  -- ADD A, R1
        6  => B"0110_0011_1000_00000000",  -- MOV R3, A
        8  => B"1010_1000_0010_00000000",  -- AND A, R2
        9  => B"0111_1000_0000_00000000",  -- CMP A, R0
        10 => B"0001_1111001_000_001_000", -- BEQ ESCREVE_RAM (addr -7)
        
        11 => B"0101_0011_000000000010", -- LD R3, 2
        12 => B"0101_0010_000000000110", -- LD R2, 6
        
        -- LOOP_EXCLUI_MULTIPLOS
        13 => B"1001_0100_0011_00000000",  -- LW R4, (R3)
        14 => B"0110_1000_0100_00000000",  -- MOV A, R4
        15 => B"0111_1000_0000_00000000",  -- CMP A, R0
        16 => B"0001_0100010_000_101_000", -- BNE EH_PRIMO (addr +34)
        
        -- INCREMENTA_J
        17 => B"0110_1000_0011_00000000",  -- MOV A, R3
        18 => B"0010_1000_0001_00000000",  -- ADD A, R1
        19 => B"0110_0011_1000_00000000",  -- MOV R3, A
        22 => B"0111_1000_0010_00000000",  -- CMP A, R2
        23 => B"0001_1110110_000_100_000", -- BLT LOOP_EXCLUI_MULTIPLOS (-10)

        25 => B"0101_0011_000000000000", -- LD R3, 0
        26 => B"0110_1000_0011_00000000",  -- MOV A, R3
        27 => B"0101_0010_000000100000", -- LD R2, 32
                
        -- MOSTRA_RESULTADO
        28 => B"0101_0101_011101010010",  -- LD R5, 11101010010
        29 => B"0110_1000_0011_00000000",  -- MOV A, R3
        30 => B"1001_0110_0011_00000000",  -- LW R6, (R3)
        31 => B"0010_1000_0001_00000000",  -- ADD A, R1
        32 => B"0110_0011_1000_00000000",  -- MOV R3, A
        33 => B"0110_0100_0110_00000000",  -- MOV R4, R6
        34 => B"0110_1000_0110_00000000",  -- MOV A, R6
        35 => B"0101_1111_000000011011",  -- LD RF, 27
        36 => B"0111_1000_0000_00000000", -- CMP A, R0
        37 => B"0001_0000110_000_001_000", -- BEQ INCREMENTA_DIVISOR (addr 6)
        38 => B"0001_0101001_000_101_000", -- BNE CALCULA_MODULO_RESULTADO (addr 41)
        
        -- CONTINUA_RESULTADO
        39 => B"0110_1000_0101_00000000",  -- MOV A, R5
        40 => B"0111_1000_0000_00000000",  -- CMP A, R0
        41 => B"0001_0000010_000_101_000", -- BNE INCREMENTA_DIVISOR (addr 41)
        42 => B"0110_0111_0100_00000000",  -- MOV R7, R4 -- Se o resto for zero, mostra o divisor
        
        -- INCREMENTA_DIVISOR
        43 => B"0110_1000_0011_00000000",  -- MOV A, R3
        44 => B"1010_1000_0010_00000000",  -- AND A, R2
        45 => B"0111_1000_0000_00000000",  -- CMP A, R0
        46 => B"0001_1101110_000_001_000", -- BEQ MOSTRA_RESULTADO (addr -18)
        
        47 => B"1111_0000000000000000",  -- END
        
        -- EXCLUI_MULTIPLO
        48 => B"1000_0000_0110_00000000",  -- SW R0, (R6) //Escreve zero no endereço (R6) da ram
        49 => B"0001_0111100_000_000_000", -- B INCREMENTA_NUMBER (ABS 60)
        
        -- EH_PRIMO
        50 => B"0110_1000_0100_00000000",  -- MOV A, R4
        51 => B"0010_1000_0001_00000000",  -- ADD A, R1
        52 => B"0110_0110_1000_00000000",  -- MOV R6, A
        53 => B"0101_0010_000000100000", -- LD R2, 32
        
        -- PROCURA_MULTIPLOS
        54 => B"0110_0101_0110_00000000",  -- MOV R5, R6
        55 => B"0101_1111_000000110010", -- LD RF, 50
        56 => B"0001_1000101_000_000_000", -- B CALCULA_MODULO (ABS 69)
        
        -- CONTINUA_MULTIPLO
        57 => B"0110_1000_0101_00000000",  -- MOV A, R5 -- Se o resto for zero, exclui
        58 => B"0111_1000_0000_00000000",  -- CMP A, R0
        59 => B"0001_1110101_000_001_000", -- BEQ EXCLUI_MULTIPLO (addr 48)
        
        -- INCREMENTA_NUMBER
        60 => B"0110_1000_0110_00000000",  -- MOV A, R6
        61 => B"0010_1000_0001_00000000",  -- ADD A, R1
        62 => B"0110_0110_1000_00000000",  -- MOV R6, A
        64 => B"1010_1000_0010_00000000",  -- AND A, R2
        65 => B"0111_1000_0000_00000000",  -- CMP A, R0
        66 => B"0001_1110100_000_001_000", -- BEQ PROCURA_MULTIPLOS (addr 54)
        67 => B"0101_0010_000000000110", -- LD R2, 6
        68 => B"0001_0010001_000_000_000", -- B INCREMENTA_J (ABS 17)
        
        -- CALCULA_MODULO
        69 => B"0110_1000_0101_00000000",  -- MOV A, R5
        70 => B"0111_1000_0100_00000000",  -- CMP A, R4
        71 => B"0001_0000100_000_100_000", -- BLT ENCONTRA_DESTINO (addr +4)
        72 => B"0100_1000_0100_00000000",  -- SUB A, R4
        73 => B"0110_0101_1000_00000000",  -- MOV R5, A
        74 => B"0001_1000101_000_000_000", -- B CALCULA_MODULO (ABS 69)
        
        -- ENCONTRA_DESTINO
        75 => B"0101_1000_000000011011", -- LD A, 27
        76 => B"0111_1000_1111_00000000",  -- CMP A, RF
        77 => B"0001_1011010_000_001_000", -- BEQ CONTINUA_RESULTADO (addr -38)
        78 => B"0001_0111001_000_000_000", -- B CONTINUA_MULTIPLO (addr 57)

        -- CALCULA_MODULO_RESULTADO
        79 => B"0111_1000_0001_00000000", -- CMP A, R1
        80 => B"0001_1110101_000_101_000", -- BNE CALCULA_MODULO (addr -11)        
        81 => B"0001_0101011_000_000_000", -- B INCREMENTA_DIVISOR (abs 43)

        -- abaixo: casos omissos => (zero em todos os bits)
        others => (others=>'0')
    );



-- R0: 0
-- R1: 1 -- valor fixo para incremento
-- R2: 32 ou 5
-- R3: Contador
-- R4: Primo/Divisor
-- R5: Resto/Dividendo (1874 -> 11101010010) -> é decrementado
-- R6: Resultado da RAM e contador Number
-- R7: Divisores de 1874
-- RF: Registrador de endereço ("1111")

0.       LD R1, 1 
1.       LD R2, 32   
2.       LD R3, 1 

ESCREVE_RAM
3.       MOV A, R3 
4.       SW (A), R3
5.       ADD A, R1 
6.       MOV R3, A
8.       AND A, R2
9.       CMP A, R0  
10.      BEQ ESCREVE_RAM 

11.      LD R3, 2 
12.      LD R2, 5 
 
LOOP_EXCLUI_MULTIPLOS
13.      LW R4, (R3) 
14.      MOV A, R4 
15.      CMP A, R0 
16.      BNE EH_PRIMO

INCREMENTA_J
17.     MOV A, R3 
18.     ADD A, R1
19.     MOV R3, A
22.     CMP A, R2
23.     BGT INICIO_RESULTADO
24.     B LOOP_EXCLUI_MULTIPLOS

INICIO_RESULTADO
24.     LD R3, 0
25.     MOV A, R3
26.     LD R2, 32
27.     LD R5, 11101010010 

MOSTRA_RESULTADO
28.     MOV A, R3 
29.     LW R6, (R3) 
30.     ADD A, R1
31.     MOV R3, A
32.     MOV R4, R6
33.     MOV A, R6
34.     LD RF, 27  
35.     CMP A, R0 
36.     BEQ INCREMENTA_DIVISOR
37.     BNE CALCULA_MODULO

CONTINUA_RESULTADO
38.     MOV A, R5 
39.     CMP A, R0 
40.     BNE INCREMENTA_DIVISOR
41.     MOV R7, R4

INCREMENTA_DIVISOR
42.     MOV A, R3
44.     AND A, 32
45.     CMP A, R0
46.     BEQ MOSTRA_RESULTADO 

47.     END

EXCLUI_MULTIPLO
48.     SW R0, (A)
49.     B INCREMENTA_NUMBER 

EH_PRIMO 
50.     MOV A, R4 
51.     ADD A, R1 
52.     MOV R6, A
53.     LD R2, 32
        
PROCURA_MULTIPLOS
54.     MOV R5, R6
55.     LD RF, 50 
56.     B CALCULA_MODULO  

CONTINUA_MULTIPLO
57.     MOV A, R5
58.     CMP A, R0 
59.     BEQ EXCLUI_MULTIPLO

INCREMENTA_NUMBER
60.     MOV A, R6
61.     ADD A, R1
62.     MOV R6, A
64.     AND A, 32
65.     CMP A, R0 
66.     BEQ PROCURA_MULTIPLOS
67.     LD R2, 5
68.     B INCREMENTA_J 
 
CALCULA_MODULO
69.     MOV A, R5 
70.     CMP A, R4 
71.     BLT ENCONTRA_DESTINO
72.     SUB A, R4 
73.     MOV R5, A 
74.     B CALCULA_MODULO 


ENCONTRA_DESTINO
75.     LD A, 27
76.     CMP A, RF
77.     BEQ CONTINUA_RESULTADO
78.     B CONTINUA_MULTIPLO 

CALCULA_MODULO_RESULTADO
79.     CMP A, R1
80.     BNE CALCULA_MODULO (addr 69)
81.     B INCREMENTA_DIVISOR